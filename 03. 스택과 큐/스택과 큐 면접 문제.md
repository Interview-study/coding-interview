# 스택과 큐 면접 문제

### 3.1 한 개로 세 개

배열 한 개로 스택 세 개를 어떻게 구현할지 설명하라.

1. 배열을 1/3씩 나누어서 각각을 스택으로 구현
2. 각 스택의 마지막 원소에 포인터를 만들고, 3칸 간격으로 스택 구현
3. 공간 분할을 유연하게 할 수 있는 방법

    → 스택의 메타 데이터를 가지는 StackInfo 클래스를 만들고, 배열을 균등한 사이즈로 나누어 원하는 갯수의 스택으로 초기화, 배열의 인덱스를 순환해서 계산할 수 있도록 기능 구현

    → 특정 스택이 가득 차면 다음 스택을 한 칸씩 shift시킴.

### 3.2 스택 Min

기본적인 push와 pop 기능이 구현된 스택에서 최솟값을 반환하는 min 함수를 추가하려고 한다. 어떻게 설계할 수 있겠는가? push, pop, min 연산은 모두 O(1) 시간에 동작해야한다.

1. ~~스택에 멤버 변수 추가 → 최소값이 pop될 때 멤버 변수를 갱신해야하는데 O(n)~~
2. 스택의 노드에 처음부터 자신까지 값 중 최소값을 가지도록
3. 2번 방법의 공간 효율 개선 방법: 최소값을 기록하는 스택을 내부에 하나 더 둔다.

### 3.3 접시 무더기

접시 무더기를 생각해보자. 접시를 너무 높이 쌓으면 무너져 내릴 것이다. 따라서 현실에서는 접시를 쌓다가 무더기가 어느 정도 높아지면 새로운 무더기를 만든다. 이것을 흉내내는 자료구조 SetOfStacks를 구현해보라. SetOfStacks는 여러 개의 스택으로 구성되어 있으며, 이전 스택이 지정된 용량을 초과하는 경우 새로운 스택을 생성해야 한다. SetOfStakcs.push()와 SetOfStacks.pop()은 스택이 하나인 경우와 동일하게 동작해야 한다(다시 발해, pop()은 정확히 하나의 스택이 있을 때와 동일한 값을 반환해야한다.)

*연관문제: 특정한 하위 스택에 대해서 pop을 수행햐는 popAt(int index) 함수를 구현하라.

1. SetOfStacks가 stack을 가지는 stack으로 구현, stack이 최대 사이즈를 넘기면 새로운 stack 추가
2. popAt기능을 위해 SetOfStacks가 stack을 가지는 arrayList를 가지도록 구현

    → 중간 스택이 가득차도록 다음 스택에서 원소를 이동 or 그대로 두기

### 3.4 스택으로 큐

스택 두 개로 큐 하나를 구현한 MyQueue 클래스를 구현하라.

1. 한 스택은 add, 한 스택은 remove를 위해서 사용 O(2N)
    - add: add 스택에 push
    - remove: add 스택의 값을 remove스택으로 한 원소를 빼고 옮긴 후 다시 add 스택으로 옮기기.
2. 최적화 → remove 시, remove를 위한 스택이 비어있을 때만 add의 스택에서 원소값 shift

### 3.5 스택 정렬

가장 작은 값이 위로 오도록 스택을 정렬하는 프로그램을 작성하라. 추가적으로 하나 정도의 스택은 사용해도 괜찮지만, 스택에 보관된 요소를 배열 등의 다른 자료구조로 복사할 수는 없다. 스택은 push, pop, peek, isEmpty의 네 가지 연산을 제공해야 한다.

1. 새로운 스택을 하나 만들어서 큰 수가 위에 오게 정렬. 그 후 새 스택에서 원소들을 꺼내면서 기존 스택에 작은 수가 위에 오도록 이동. O(N^2) 시간, 공간 O(N)

    → 기존 스택에서 값을 하나 빼서 임시 변수에 담고, 정렬된 새로운 스택에서 임시 변수값보다 큰 값을 기존 스택으로 이동. 기존 스택의 모든 값이 새 스택으로 모두 옮겨질때까지 반복.

2. 스택을 무한정 사용할 수 있다면, 병합 정렬, 퀵 정렬. 

### 3.6 동물 보호소

먼저 들어온 동물이 먼저 나가는 동물 보호소가 있다고 하자. 이 보호소는 개와 고양이만 수용한다. 사람들은 보호소에서 가장 오래된 동물부터 입양할 수 있는데, 개와 고양이 중 어떤 동물을 데려갈지 선택할 수 있다. 하지만 특정 동물을 지정해서 데려갈 수는 없다. 이 시스템을 자료구조로 구현하라. 이 자료구조는 enqueue, dequeueAny, dequeueDog, dequeueCat의 연산을 제공해야 한다. 기본적으로 탑재되어 있는 LinkedList 자료구조를 사용해도 좋다.

1. 보호소에 2개의 first, last 참조 포인터(dog, cat 각각) 추가 = 2개의 큐

    → 2개의 큐를 직접 구현하지 않고 LinkedList 2개 참조할 수 있다.

    → dequeueAny 연산을 위해서 타임스탬프 혹은 order 값 필요

2. 하나의 큐에 dequeueDog, dequeueCat 연산 생성 → 뒤로 순회하면서 dog, cat에 해당하는 애 리턴 & 연결 수정