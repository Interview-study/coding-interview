# 02. 연결 리스트



 연결 리스트는 차례로 연결된 노드를 표현해주는 자료구조이다.



- 단방향 연결 리스트 : 각 노드는 다음 노드를 가리킨다.
- 양방향 연결 리스트 : 각 노드는 다음 노드와 이전 노드를 함께 가리킨다. 



## 연결 리스트의 장단점

### 장점

- 시작 지점에서 아이템을 추가하거나 삭제하는 연산을 상수 시간에 할 수 있다.

### 단점

- 특정 인덱스를 상수 시간에 접근할 수 없다.



### 연결 리스트 만들기

```java
class Node {
  Node next = null;
  int data;
  public Node(int d) {
    data = d;
  }
  
  void appendToTail(int d) {
    Node end = new Node(d);
    Node n = this;
    while (n.next != null) {
      	n = n.next;
		}
    n.next = end;
	}
}
```



 위와 같이 LinkedLIst 자료 구조를 사용하지 않고 연결 리스트에 접근할 때 head 노드의 주소를 참조하는 방법을 사용했다. 위와 같이 구현할 땐 여러 객체들이 동시에 연결리스트를 참조하는 도중에 head가 바뀌면 어떻게 해야할지 생각해봐야한다. head가 바뀌었음에도 불구하고 어떤 객체들은 이전 head를 계속 가리키고 있을 수도 있다.



 할 수 있다면 Node 클래스를 포함하는 LinkedList 클래스를 만드는 것이 좋다. 그렇게 하면 해당 클래스 안에 head Node 변수를 단 하나만 정의해 놓음으로써 위의 문제점을 완전히 해결할 수 있기 때문이다.



## 단방향 연결리스트에서 노드 삭제 

 연결리스트에서 노드를 삭제하는 연산은 꽤 직관적이다. 노드 n이 주어지면, 그 이전 노드 prev를 찾아 prev.next를 n.next와 같도록 설정한다. 리스트가 양방향 연결리스트인 경우에는 n.next가 가리키는 노드를 갱신하여 n.next.prev가 n.prev와 같도록 설정해야한다.



### 유의해야할 점

- 널 포인터 검사를 반드시 해야한다.
- 필요하면 head와 tail포인터도 갱신해야한다.



 ## Runner(부가 포인터) 기법



연결 리스트를 순회할 때 두 개의 포인터를 동시에 사용하는 방법이다. 이 때 한 포인터가 다른 포인터보다 앞서도록 한다. 예를 들어 앞선 포인터가 따라오는 포인터보다 항상 지정된 개수만큼을 앞서도록 할 수도 있고, 아니면 따라오는 포인터를 여러 노드를 한 번에 뛰어넘도록 설정할 수도 있다.



## 재귀 문제

 상당 수의 연결리스트 관련 문제는 재귀 호출에 의존한다. 연결 리스트 문제를 푸는 데 어려움을 겪고 있다면, 재귀적 접근법은 통할지 확인해야한다.







