# 05. 비트 조작 개념



## 손으로 비트 조작 해보기



>  아래 문제의 모든 숫자는 4비트 숫자이다. 



`0110 + 0110` 

같은 값을 두 번 더하는 것은 왼쪽 시프트 연산을 한 번 한 것과 같다.



`0100 * 0011`

0100은 4를 의미한다. 4를 곱하는 것은 왼쪽 시프트 연산 두 번과 같다.



`1101 ^ (~1101)` 

`a^(~a)` 과 같다. 모든 비트가 반대되는 수끼리 XOR 연산을 하면 값은 모든 비트가 1이 나온다.



`1011 & (~0 << 2)`

`~0` 을 하면 모든 비트가 1이된다. 즉, `~0` 의 값이 1111이 된다. 1111 << 2는 1100이 된다. 1011 & 1100을 하게 되면 1000이 된다. 



## 비트 조작을 할 때 알아야할 사실들과 트릭들

 아래 표현식들이 왜 참이 되는지 생각해보자.

`0s` 는 모든 비트가 0인 값이고, `1s` 는 모든 비트가 1인 값을 나타낸다.

```
x ^ 0s = x
x & 0s = 0
x | 0s = x

x ^ 1s = ~x
x & 1s = x
x | 1s = 1s

x ^ x = 0
x & x = x
x | x = x
```



위의 표현식들의 모든 연산들이 비트 단위로 이루어진다는 사실을 명심하자. `한 비트에서 일어나는 일이 다른 비트에 어떤 영향도 미치지 않는다.`



## 2의 보수와 음수



> 2의 보수는 어떤 수를 커다란 2의 제곱수에서 빼서 얻은 이진수이다. 2의 보수는 대부분의 산술연산에서 **원래 숫자의 음수**처럼 취급된다. 주어진 이진수보다 한 자리 높고 가장 높은 자리가 1이며 나머지가 0인 수에서 주어진 수를 빼서 얻은 수가 2의보수이다. 혹은 주어진 이진수의 모든 자리의 숫자를 반전시킨 뒤 여기에 1을 더하면 2의 보수를 얻을 수 있다.
>
> *2의 보수를 구하는 방법 1*
>
> 8자리의 이진수 01001011([십진수](https://ko.wikipedia.org/wiki/십진법)로 75)의 2의 보수를 구하면 아래와 같다.
>
> ```
>     100000000 (8+1=9자리) --> 256
>   -) 01001011 (8자리) ---> 75
>   -----------
>      10110101 (8자리) ---> 181
> ```
>
> *2의 보수를 구하는 방법 2*
>
> [1의 보수](https://ko.wikipedia.org/wiki/1의_보수)를 이용하여 2의 보수를 구하면 아래와 같다.
>
> ```
>      01001011 의 모든 자리의 수를 반전시킨다.
>      10110100 (이것을 1의 보수라고 부른다)
>               여기에 1을 더한다.
>      10110100 ---> 180
>   +) 00000001 ---> 1
>   -----------
>      10110101 ---> 181
> ```
>
> 보수를 구하며 한 자리가 더 길어진 경우에는 가장 높은 자리의 숫자를 버린다.



> **컴퓨터에서 음수를 표현할 때 왜 2의 보수를 사용할까?** 
>
> - ?



 컴퓨터는 일반적으로 정수를 저장할 때 2의 보수 형태로 저장한다. 양수를 표현할 때는 아무 문제 없지만 음수를 표현할 때는 그 수가 절대값에 부호비트를 1로 세팅한 뒤 2의 보수를 취한 형태로 표현한다. N비트 숫자에 대한 2의 보수는 2^N에 대한 보수값과 같다. 여기서 N은 부호비트를 뺀 나머지 값을 표현할 때 사용되는 비트의 개수이다. 



> 예
>
> 4비트로 표현된 정수 -3을 살펴보자. 부호 비트 하나와 나머지 세 개가 값을 표현할 것이다. 이제 2^3에 대한 보수를 구해보자. -3의 절대값인 3의 8에 대한 보수는 5가 된다. 5를 2진수로 표현하면 101이 되고, 따라서 -3을 4비트의 2진수로 표현하면 1101이 된다. 여기서 첫 비트는 부호 비트를 나타낸다. 



**위의 예처럼 -K를 N비트의 2진수로 나타내면 `concat(1, 2^(N - 1) - K)`이 된다.** 



2의 보수를 표현하는 다른 방법은 양수로 표현된 2 진수를 뒤집은 뒤 1을 더해주는 것이다. 예를 들어 3을 2진수로 표현하면 011이 되는데, 이 숫자를 뒤집으면 100이 되고, 여기에 1을 더하면 101이 된다. 그 다음 마지막으로 부호비트를 앞에 붙여주면 1101이 된다. 



| 양수 |      | 음수 |      |
| ---- | ---- | ---- | ---- |
| 7    | 0111 | -1   | 1111 |
| 6    | 0110 | -2   | 1110 |
| 5    | 0101 | -3   | 1101 |
| 4    | 0100 | -4   | 1100 |
| 3    | 0011 | -5   | 1011 |
| 2    | 0010 | -6   | 1010 |
| 1    | 0001 | -7   | 1001 |
| 0    | 0000 |      |      |



위 표를 보면 왼쪽과 오른쪽의 절대값을 합한 결과는 항상 2^3이 된다는 것을 알 수 있다. (eg. 7 + (-7))



또한, 부호비트를 뺀 왼쪽과 오른쪽의 2진수 값은 항상 같다는 것을 알 수 있다. 왜 이렇게 될까? 



## 산술 우측 시프트 vs 논리 우측 시프트

 산술 우측 시프트는 기본적으로 2로 나눈 결과와 같다. 논리 우측 시프트는 우리가 일반적으로 비트를 옮길 때처럼 보이는 것처럼 움직인다. 음수에 논리 우측 시프트를 적용해보며 이해해보자.



 논리 우측 시프트는 비트를 옆으로 옮긴 다음에 최상위 비트에 0을 넣는다. 즉, >>> 연산과 같다. 최상위 비트가 부호비트인 8비트 정수에 논리 우측 시프트를 적용하면 아래와 같다. 밑의 그림에서 바탕색이 회색인 부분이 부호비트를 나타낸다.

```
10110101 = -75

01011010 = 90
```

 산술 우측 시프트는 비트를 오른쪽으로 옮기긴 하지만 부호비트는 바뀌지 않는다. 따라서 이 연산은 대략 2로 나눈 효과가 있고, >> 연산과 같다.

```
10110101 = -75
11011010 = -38

(양수니까) 75 >> 75 * 2
```



x = -93242, count = 40일 때 아래 함수에 대입해보자.

![image](https://user-images.githubusercontent.com/34959979/111419862-89cb1d00-872d-11eb-9386-ac784fed9ef8.png)



![image](https://user-images.githubusercontent.com/34959979/111419875-8cc60d80-872d-11eb-8ca6-ff70749c9a1a.png)



논리 시프트를 사용하면 최상위 비트에 0을 반복적으로 채워 넣으므로 결과적으로 0이 될 것이다. 산술 시프트를 사용하면 최상위 비트에 1을 반복적으로 채워 넣게 되므로 결과적으로 -1이 될 것이다. 모든 비트가 1로 채워져 있으면 -1이 된다.



> 이것만 기억하고 가자!
>
> `>>` : 부호 비트를 살리면서 오른쪽 시프트
>
> `>>>` : 부호 비트를 살리지 않으면서 오른쪽 시프트 



## 기본적인 비트 조작: 비트값 확인 및 채워넣기



 아래 비트 문제들을 어떻게 구현하는지 이해하고 넘어가자.



### 비트값 확인

 아래의 메서드는 1을 i비트만큼 시프트해서 00010000과 같은 값을 만든다. 그 다음 AND 연산을 통해 num의 i번째 비트를 뺀 나머지 비트를 모두 삭제한 뒤, 이 값을 0과 비교한다. 만약 이 값이 0이 아니라면 i번째 비트는 1이어야하고, 0이라면 i번째 비트는 0이어야한다. 



```java
boolean getBit(int num, int i) {
  return ((num & (1 << i)) != 0);
}
```



### 비트값 채워넣기

`SetBit` 는 1을 i비트만큼 시프트해서 0001000과 같은 값을 만든다. 그 다음 OR 연산을 통해 num의 i번째 비트값을 바꾼다. i번째를 제외한 나머지 비트들은 0과 OR 연산을 하게 되므로 num에 아무 영향을 끼치지 않는다. 



```java
int setBit(int num, int i) {
  return num | (1 << i);
}
```



### 비트값 삭제하기 

 이 메서드는 `setBit`를 거의 반대로 한 것과 같다. NOT 연산자를 이용해 (00010000)을 11101111과 같이 만든 뒤 num과 AND 연산을 수행한다. 그러면 나머지 비트의 값은 변하지 않은 채 i번째 비트값만 삭제된다.



```java
int clearBit(int num, int i) {
  int mask = ~(1 << i);
  return num & mask;
}
```



최상위 비트에서 i번째 비트까지 모두 삭제하려면 어떻게 해야할까 ? 우선 (1 << i)로 i번째 비트를 1로 세팅한 뒤 이 값에서 1을 뺀다. 그러면 i번째 비트 밑은 모두 1로 세팅되고 그 위로는 모두 0으로 세팅된다. 이 mask 값과 num을 AND 연산한다면 하위 i개의 비트를 뺀 나머지 비트를 모두 삭제할 수 있다.



```java
int clearBitMSBthroughI(int num, int i) {
  int mask = (1 << i) - 1;
  return num & mask;
} 
```



i번째 비트에서 0번째 비트까지 모두 삭제하려면 어떻게 해야할까? 

모든 비트가 1로 세팅된 -1을 왼쪽으로 i+1만큼 시프트하면 된다. 그러면 i번째 비트 위로는 모두 1로 세팅되고 하위 i개 비트는 모두 0으로 세팅된다.

```java
int clearBitsIthrough0(int num, int i) {
  int mask = (-1 << (i + 1));
  return num & mask;
}
```



### 비트값 바꾸기

 i번째 비트값을 v로 바꾸고 싶다면, 우선 11101111과 같은 값을 이용해 (i=4인 경우) i번째 비트값을 삭제해야한다. 그 뒤 우리가 바꾸고자 하는 값 v를 왼쪽으로 i번 시프트 한다. 그러면 i번째 비트값은 v가 될 것이고 나머지는 모두 0이 될 것이다. 마지막으로 OR 연산을 이용해 i번째 비트값을 v로 바꿔준다.

```java
int updateBit(int num, int i, boolean bitIs1) {
  int value = bitIs1 ? 1 : 0;
  int mask = ~(1 << i);
  return (num & mask) | (value << i);
}
```



