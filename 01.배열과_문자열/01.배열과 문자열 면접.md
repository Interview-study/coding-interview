# 01. 배열과 문자열



## 면접 문제



### 1.1 중복이 없는가?

문자열이 주어졌을 때, 이 문자열에 같은 문자가 중복되어 등장하는지 확인하는 알고리즘을 작성하라. 자료 구조를 추가로 사용하지 않고 풀 수 있는 알고리즘 또한 고민하라.



set을 사용하여 문제를 해결할 것 같습니다. Set 자료구조도 HashMap에서 key만으로 구현되어 있습니다.



1. 자료 구조를 추가로 사용하지 않고 풀기 위해서는 두 개의 반복문을 사용하여 같은 문자가 반복되는지 확인할 것 같습니다. 
2. 문자열을 sprint한 뒤 String[] 로 변환한 뒤 Arrays.sort를 하여 다음 원소와 같은 값을 비교하면 O(N)의 시간복잡도로 구현할 수 있을 것 같습니다.



> - 비트 벡터란? 

### 1.2 순열 확인

문자열이 두 개 주어졌을 때 이 둘이 서로 순열 관계에 있는지 확인하는 메서드를 작성하라



1. 순열 관계가 무엇인지 되묻는다.
2. 해쉬맵으로 각 단어가 몇번 쓰였는지를 계산한 뒤 같은 단어를 같은 수로 사용했다면 순열관계가 성립한다. 이 방법은 O(N)이 걸린다.
3. 둘다 Arrays.sort 해본 뒤 비교한다. 이 방법은 O(NlogN)이 걸린다. 



> - 최적화 할 수 있는 방법으로 문자열의 길이가 다른지 파악할 수 있다.



### 1.3 URL화

 문자열에 들어 있는 모든 공백은 '%20'으로 바꿔주는 메서드를 작성하라. 최종적으로 모든 문자를 다 담을 수 있을 만큼 충분한 공간이 이미 확보되어 있으며 문자열의 최종 길이가 함께 주어진다고 가정해도 된다. (자바로 구현한다면 배열 안에서 작업할 수 있도록 문자 배열을 이용하길 바란다.)



- Java의 String.replace 메서드를 사용하겠다.



> 문자열 조작 문제를 풀 때는 문자열을 뒤에서부터 거꾸로 편집해나가는 방법을 많이 사용한다. 이렇게 해야 마지막 부분에 여유 공간을 만들어 유용하게 사용할 수 있기 때문이다. 
>
> 1. 문자열 내에 얼마나 많은 공백 문자가 있는지 살핀 뒤, 이를 통해 최종 문자열에 추가 공간이 얼마나 필요한지 계산한다.
> 2. 역방향으로 진행하면서 실제로 문자열을 편집한다. 



### 1.4 회문 수열

 주어진 문자열이 회문(palindrome)의 순열인지 아닌지 확인하는 함수를 작성하라. 회문이란 앞으로 읽으나 뒤로 읽으나 같은 단어 혹은 구절을 의미하며, 순열이란 문자열을 재배치하는 것을 뜻한다. 회문이 꼭 사전에 등장하는 단어로 제한될 필요는 없다.



- 대문자 소문자를 어떻게 처리할 지 물어본다.
- 공백을 어떻게 처리할지 물어본다. 

- 첫 값과 마지막, 그 다음 값과 마지막 전 값처럼 비교해가며 문자를 비교할 것이다. 



> - 해시테이블을 사용해 본 적이 있는가? O(N) 시간으로 줄일 수 있다.



> 위 문제에서 회문의 순열이라는 말의 의미를 이해하지 못했다. 
>
> - 하나의 홀수, 짝수 개의 문자를 가지고 있는지 확인하면 된다. 



### 1.5 하나 빼기

문자열을 편집하는 방법에는 세 가지 종류가 있다. 문자 삽입, 문자 삭제, 문자 교체 문자열 두 개가 주어졌을 때, 문자열을 같게 ㅁ나들기 위한 편집 횟수가 1회 이내인지 확인하는 함수를 작성하라.



> 이건 손도 못댔다. 젠장!



### 1.6 문자열 압축

반복되는 문자의 개수를 세는 방식의 기본적인 문자열 압축 메서드를 작성하라. 예를 들어 문자열 aabccccaaa를 압축하면 a2b1c5a3이 된다. 만약 '압축된' 문자열의 길이가 기존 문자열의 길이보다 길다면 기존 문자열을 반환해야한다. 문자열은 대소문자 알파벳(a~z)으로만 이루어져 있다.



- 간단하게는 첫 문자부터 마지막 문자까지 검사해가며 하나씩 검사해가면 숫자를 StringBuilder에 삽입한다.
- StringBuilder로 압축된 문자열과 기존 문자열의 길이를 비교하여 기존 문자열의 길이가 더 짧다면 기존 문자열을 반환한다.



> 최적화할 수 있는 방법은 없을까요?
>
> - 문자열을 반복해서 이어붙이지 말자. 다음 문자열을 확인할 때 다음 문자열이 현재 문자열과 다를 때 그 수만큼 문자열을 한번에 이어 붙이므로 매번 문자열을 붙이는 비용을 감소시킬 수 있다.



### 1.7 행렬 회전

 이미지를 표현하는 N*N 행렬이 있다. 이미지의 각 픽셀은 4바이트로 표현된다. 이때, 이미지를 90도 회전시키는 메서드를 작성하라. 행렬을 추가로 사용하지 않고서도 할 수 있는가? 



- 행렬을 추가로 사용하지 않고 사용하는 방법은 모르겠습니다.
- 그렇지 않다면 이중 포문을 사용합니다.
- `a[i][j]` => `a[j][N-i]` 의 형태로 변경하면 됩니다.



> 더 나은 답
>
> - 배열의 가장 바깥 영역, 즉, 배열의 껍데기끼리 변경해보자.
> - 행렬을 추가로 사용하지 않게하려면 temp 변수를 하나 둔 뒤 시계 방향으로 모든 껍데기를 변경해보자.



### 1.8 0 행렬

M * N 행렬의 한 원소가 0일 경우, 해당 원소가 속한 행과 열의 모든 원소를 0으로 설정하는 알고리즘을 작성하라.



- 배열을 복사해 배열을 두 개 둔 뒤 첫번째 배열은 검사용 배열로 0을 발견했을 때 두번째 배열의 값들을 0으로 변경해보자.
  - 공간 복잡도 면에서 O(M*N)을 가진다. 



> 배열을 하나만 써야할 경우?
>
> - 0을 발견했을 때 행과 열의 값을 음수화 한다.
> - 음수화 했을 경우 0에는 아무 효과가 없다.
> - 마지막으로 모든 음수의 값을 0으로 만들어준다.



> 최적화면에서 더 나은 답
>
> 1. 0인 원소의 행과 열을 담아 자료 구조에 담고 그 자료 구조를 꺼내가며 행과 열을 0으로 만든다.
>    - 배열의 모든 값을 점검할 필요가 없다.
> 2. 0인 원소가 존재하면 그 원소의 행과 열 모든 정보가 다 필요하지 않다. 해당하는 원소의 행과 열이 0으로 변경해야할 것임을 알고 있기만 하면 된다.
>    - `boolean[] row = new boolean[행의 사이즈]`
>    - `boolean[] col = new boolean[열의 사이즈]`
>    - 위와 같은 자료 구조를 사용하면 O(N)의 공간복잡도를 가진다.
> 3. 첫 행과 첫 열에 0이 존재하는 지 파악한 뒤 이를 boolean 변수로 둔 뒤 첫 행과 첫 열에 위와 같이  0으로 변해야하는 행과 열임을 표시한다. 



### 1.9 문자열 회전

 한 단어가 다른 문자열에 포함되어 있는지 판별하는 isSubstring이라는 메서드가 있다고 하자. s1과 s2의 두 문자열이 주어졌고, s2가 s1을 회전시킨 결과인지 판별하고자 한다(가령 'waterbottle'은 'erbottlewat'을 회전시켜 얻을 수 있는 문자열이다). isSubstring 메서드를 한 번만 호출해서 판별할 수 있는 코드를 작성하라.



- 우선 문자열을 검사해서 문자열의 크기가 다르면 바로 false 반환
- 이후에는 찍소리도 못함



> - "waterbottle", "erbottlewat"의 관계를 살펴보면 x = wat, y = erbottle이라고 했을 때 watterbottle은 xy이고 erbottlewat은 yx이다. 이를 생각해보면 xyxy로 이루어진 문자열에는 항상 yx를 포함하고 있다는 뜻이다.

